# miniEMC2 - what is it? #
Why Linux and EMC2? I would say the idea of implementation of G-code interpreter from scratch is not very simple task and author hardly would started such a project considering it as a hobby. But he would like to implement something cheap and simple. He even managed to find clipped EMC2 project ( detached from Linux and used no OS ) and pack in into small ARM7 MCU - thanks to guys from here http://www.oemtech.com/gcodecompiler/. But, performance of that MCU was not very well and small amount of internal memory added some restrictions. However, it was some years ago and and new generation of Cortex-M4 now is fast enough to satisfy that requirements. But in the author's mind appeared idea to port core of EMC2 project to embedded Linux device. That time a widely used board was mini2440, so it was decided to use one for experiments.
First attempts to build EMC2 in simulation mode showed satisfying results ( it's valid for EMC2 version 2.2.0, but with 2.4.0 ,seems, requires much more computation ). It was the version without GUI and HAL drivers-system was controlled over Ethernet with TkEMC. The next task was an implementation of Hard RealTime with such accuracy to be able to make step pulses with acceptable frequency and jitter. The solution appeared unexpectedly when author was looking over source code of  GTA02 project and found there an interesting trick with Fast Interrupt reQuest ( FIQ). FIQ is similar to usual IRQ, but response time is high little bit and the main advantage FIQ have the highest priority and they don't have any infrastructure in the kernel. Usual IRQ is wrapped in special handlers and demultiplexers, they can be disabled at the any time. But FIQ doesn't have any of this disadvantages.  That way FIQ suited well to be used for pseudo Hard Real-Time system. Measured latency was about 1-3 uS, that was enough to make stable STEP pulses. But FIQ it's only the half of the problem. The second half of problem was to ensure also more "soft" real time for trajectory computation. The solution was found when Xenomia's developer added S3C2440 support to I-PIPE. Test showed latency about 100 uS under high I/O load. Not the best result, but was decided to try port RTAPI to Xenomai. To simplify the porting task was decided to substitute LIBPTH's calls with wrapped Xenomai Native skin's calls using SIM\_RTAPI port as a base. As a result we have next project structure:

![http://3.bp.blogspot.com/-VmAM5UCNsIs/ToTLogTzFiI/AAAAAAAAAAY/Uh9Lzn5izDI/s1600/miniemc2_funcd.png](http://3.bp.blogspot.com/-VmAM5UCNsIs/ToTLogTzFiI/AAAAAAAAAAY/Uh9Lzn5izDI/s1600/miniemc2_funcd.png)

_Motion controller_ and _IO controller_ are parts of EMC2. _IO controller_ works in User space, because it doesn't require high latency.
_Motion controller_ this is part of HAL subsystem and has to work in real time, cause it generates stream of trajectory's points with Servo Cycle rate ( usual value is 1 mS ). Latency value of 100 uS with 1000 uS servocycle time might cause unstable behavior of motion part, so was decided to add trajectory point's buffer ( point's FIFO ). But first let's take a look at non-standard HAL component called _miniemcdrv.so_. This component is dedicated to be used on our platform only. Together with FIQ handlers they provide functions similar to ones proided by Stepgen and Parport on x86. That is, in _miniemcdrv.so_ tasks are included reception of trajectory point's stream from _Motion controller_, converting them to value of Frequency synthesizers, I-regulator of an actual position, polling of Digital Inputs (GPIO), PWM/ DO value computation, data transferring to/from FIQ handler. In fact, servocycle's period selected a little less that 1 mS to be able fill point's FIFO. Also was added _miniemcdrv.so_ to _Motion contorller_ feedback pin to avoid FIFO overflow. _miniemcdrv.so_ output's data are placed into dedicated "kernel - user space" shared memory and FIQ handler fetch/store data to/from there. FIQ handler is called every 10 uS providing maximum STEP frequency about 50 kHz. Inside FIQ handler occurs frequency  synthesis and Digital Output control. Also it provides actual axes position, which are taken into account in position I-regulator at _miniemcdrv.so_.

To be continued...